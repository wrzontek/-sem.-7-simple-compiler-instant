/* File generated by the BNF Converter (bnfc 2.9.3) (Test.C) and then modified by me */

#include <cstdio>
#include <string>
#include <iostream>
#include <filesystem>
#include "Parser.H"
#include "Absyn.H"
#include "ParserError.H"
#include "LLVM_Compiler.cpp"
#include "JVM_Compiler.cpp"

void usage() {
    printf("usage: ./Compiler <input_file> <jvm/llvm>:\n");
}

int main(int argc, char **argv) {
    FILE *input;
    char *filename;
    std::string compiler_type;

    if (argc != 3) {
        usage();
        exit(1);
    }
    filename = argv[1];
    compiler_type = argv[2];
    auto path = std::filesystem::path(filename);
    std::string filename_no_extension = path.filename().replace_extension("");

    input = fopen(filename, "r");
    if (!input) {
        usage();
        exit(1);
    }
    if (compiler_type != "jvm" && compiler_type != "llvm") {
        usage();
        exit(1);
    }

    /* The default entry point is used. For other options see Parser.H */
    Program *parse_tree = nullptr;
    try {
        parse_tree = pProgram(input);
    } catch (parse_error &e) {
        std::cerr << "Parse error on line " << e.getLine() << "\n";
    }
    if (parse_tree) {
        if (compiler_type == "llvm") {
            auto compiler = new LLVM_Compiler(parse_tree,
                                              path.replace_extension(".ll"));
            compiler->compile();
            delete (compiler);
        } else {
            auto compiler = new JVM_Compiler(parse_tree, filename_no_extension,
                                             path.replace_extension(".j"));
            compiler->compile();
            delete (compiler);
        }
        fclose(input);
        delete (parse_tree);
        return 0;
    }
    return 1;
}

